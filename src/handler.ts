import { HandlerError, Link, OperationInfo } from "./api";
import { Operation, OperationMap, Service } from "./operation";
import { LazyValue } from "./serializer";

/**
 * General handler context that is common to all handler methods.
 */
export interface OperationContext {
  /** Name of the service that contains the operation. */
  service: string;
  /** Name of the operation. */
  operation: string;
  /** Request header fields. */
  headers: Record<string, string>;
  /** Signaled when the current request is canceled. */
  abortSignal: AbortSignal;
}

/**
 * Context for the {@link OperationHandler["start"]} method.
 */
export interface StartOperationContext extends OperationContext {
  /**
   * Callbacks are used to deliver completion of async operations.
   * This value may optionally be set by the client and should be called by a handler upon completion if the started
   * operation is async.
   */
  callbackURL?: string;
  /**
   * Optional header fields set by a client that are required to be attached to the callback request when an
   * asynchronous operation completes.
   */
  callbackHeaders?: Record<string, string>;
  /**
   * Request ID that may be used by the server handler to dedupe a start request.
   * By default a v4 UUID will be generated by the client.
   */
  requestId?: string;
  /**
   * Links that contain arbitrary caller information, used as metadata for the call.
   */
  callerLinks: Link[];

  /**
   * Links that may be attached by handler implementations to be propagated back to the caller.
   * 
   * Handlers should mutate this array directly, e.g. by calling `push` directly.
   */
  handlerLinks: Link[];
}

/**
 * Context for the {@link OperationHandler["getInfo"]} method.
 */
export type GetOperationInfoContext = OperationContext

/**
 * Context for the {@link OperationHandler["getResult"]} method.
 */
export interface GetOperationResultContext extends OperationContext {
  /**
   * If specified and non-zero, reflects the duration the caller has indicated that it wants to wait for operation
   * completion, turning the request into a long poll.
   */
  wait: number;
}

/**
 * Context for the {@link OperationHandler["cancel"]} method.
 */
export type CancelOperationContext = OperationContext

/** A result that indicates that an operation completed successfully. */
export interface HandlerStartOperationResultSync<T> {
  value: T;
}

/** A result that indicates that an operation has been accepted and will complete asynchronously. */
export interface HandlerStartOperationResultAsync {
  /**
   * A token to identify the operation in followup handler methods such as {@link OperationHandler["getResult"]} and
   * {@link OperationHandler["cancel"]}.
   */
  token: string;
}

/**
 * The return type from the {@link OperationHandler["start"]}. May be synchronous or asynchronous.
 */
export type HandlerStartOperationResult<T> = HandlerStartOperationResultSync<T> | HandlerStartOperationResultAsync;

/**
 * A handler for an operation.
 */
export interface OperationHandler<I, O> {
  /**
   * Handles requests for starting an operation.
   *
   * Return {@link HandlerStartOperationResultSync} to respond successfully - inline, or
   * {@link HandlerStartOperationResultAsync} to indicate that an asynchronous operation was started. Throw a
   * {@link OperationError} to indicate that an operation completed as failed or canceled.
   */
  start(ctx: StartOperationContext, input: I): Promise<HandlerStartOperationResult<O>>;

  /**
   * Handles requests to get the result of an asynchronous operation. Return non error result to respond successfully -
   * inline, or error with {@link OperationStillRunningError} to indicate that an asynchronous operation is still
   * running.
   *
   * Throw an {@link OperationError} to indicate that an operation completed as failed or canceled.
   *
   * When {@link GetOperationResultContext["wait"]} is greater than zero, this request should be treated as a long poll.
   * Note that the specified wait duration may be longer than the configured client or server side request timeout, and
   * should be handled separately.
   *
   * It is the implementor's responsiblity to respect the client's wait duration and return in a timely fashion, leaving
   * enough time for the request to complete and the response to be sent back.
   *
   * @experimental
   */
  getResult(ctx: GetOperationResultContext, token: string): Promise<O>;

  /**
   * GetInfo handles requests to get information about an asynchronous operation.
   *
   * @experimental
   */
  getInfo(ctx: GetOperationInfoContext, token: string): Promise<OperationInfo>;

  /**
   * Handles requests to cancel an asynchronous operation.
   *
   * Cancelation in Nexus is:
   * 1. asynchronous - returning from this method only ensures that cancelation is delivered, it may later be
   * ignored by the underlying operation implemention.
   * 2. idempotent - implementors should ignore duplicate cancelations for the same operation.
   */
  cancel(ctx: CancelOperationContext, token: string): Promise<void>;
}

/**
 * A shortcut for defining an operation handler that only implements the {@link OperationHandler["start"]} method and
 * always returns a {@link HandlerStartOperationResultSync}.
 */
export type SyncOperationHandler<I, O> = (ctx: StartOperationContext, input: I) => Promise<O>;


/**
 * A type that defines a handler for a given operation.
 */
export type OperationHandlerFor<T> =
  T extends Operation<infer I, infer O> ? OperationHandler<I, O> | SyncOperationHandler<I, O> : never;

/**
 * A type that defines a collection of handlers for a given collection of operation interfaces.
 */
export type ServiceHandlerFor<T extends OperationMap = OperationMap> = {
  [K in keyof T & string]: OperationHandlerFor<T[K]>;
};

/**
 * A {@link Service} that includes a collection of handlers for its operations.
 */
export interface ServiceHandler<T extends OperationMap = OperationMap> extends Service<T> {
  handlers: ServiceHandlerFor<T>;
}

/**
 * Constructs a service handler for a given service contract.
 */
export function serviceHandler<T extends OperationMap>(
  service: Service<T>,
  handlers: ServiceHandlerFor<T>,
): ServiceHandler<T> {
  const ops = new Set<string>();

  for (const [k, op] of Object.entries(service.operations)) {
    if (!op.name) {
      throw new TypeError(`Tried to register an operation with no name for service ${service.name} with key ${k}`);
    }
    if (ops.has(op.name)) {
      throw new TypeError(`Operation with name ${op.name} already registered for service ${service.name}`);
    }
    const handler = handlers[k];
    if (!handler) {
      throw new TypeError(`No handler registered for ${k} on service ${service.name}`);
    }
    ops.add(op.name);
  }

  return {
    ...service,
    handlers,
  };
}

/**
 * A collection of service handlers that dispatches requests to the registered service and operation handler.
 */
export class ServiceRegistry implements OperationHandler<unknown, unknown> {
  private services = new Map<string, Map<string, OperationHandler<any, any> | SyncOperationHandler<any, any>>>();

  constructor(services: ServiceHandler[]) {
    for (const s of services) {
      if (!s.name) {
        throw new TypeError("Tried to register a Nexus service with no name");
      }
      if (this.services.has(s.name)) {
        throw new TypeError(`Duplicate registration of nexus service ${s.name}`);
      }
      const ops = new Map<string, OperationHandler<any, any> | SyncOperationHandler<any, any>>();
      for (const [k, op] of Object.entries(s.operations)) {
        if (!op.name) {
          throw new TypeError(`Tried to register an operation with no name for service ${s.name} with key ${k}`);
        }
        if (ops.has(op.name)) {
          throw new TypeError(`Operation with name ${op.name} already registered for service ${s.name}`);
        }
        const handler = s.handlers[k];
        if (!handler) {
          throw new TypeError(`No handler registered for ${k} on service ${s.name}`);
        }
        ops.set(op.name, handler);
      }
      this.services.set(s.name, ops);
    }
  }

  private getHandler(ctx: OperationContext): OperationHandler<any, any> | SyncOperationHandler<any, any> {
    const { service, operation } = ctx;
    const serviceHandler = this.services.get(service);
    if (serviceHandler == null) {
      throw new HandlerError({
        type: "NOT_FOUND",
        message: `Service handler not registered for service ${service}`,
      });
    }
    const operationHandler = serviceHandler.get(operation);
    if (operationHandler == null) {
      throw new HandlerError({
        type: "NOT_FOUND",
        message: `Operation handler not registered for operation ${operation} in service ${service}`,
      });
    }
    return operationHandler;
  }

  async start(
    ctx: StartOperationContext,
    lv: LazyValue,
  ): Promise<HandlerStartOperationResult<any>> {
    const handler = this.getHandler(ctx);
    const input = await lv.consume<any>();
    if (typeof handler === "function") {
      const value = await handler(ctx, input);
      return { value };
    }
    return await handler.start(ctx, input);
  }

  async getResult(
    ctx: GetOperationResultContext,
    token: string,
  ): Promise<LazyValue> {
    const handler = this.getHandler(ctx);
    if (typeof handler === "function") {
      throw new HandlerError({
        type: "NOT_IMPLEMENTED",
        message: "Not implemented",
      });
    }
    return await handler.getResult(ctx, token);
  }

  async getInfo(
    ctx: GetOperationInfoContext,
    token: string,
  ): Promise<OperationInfo> {
    const handler = this.getHandler(ctx);
    if (typeof handler === "function") {
      throw new HandlerError({
        type: "NOT_IMPLEMENTED",
        message: "Not implemented",
      });
    }
    return await handler.getInfo(ctx, token);
  }

  async cancel(ctx: CancelOperationContext, token: string): Promise<void> {
    const handler = this.getHandler(ctx);
    if (typeof handler === "function") {
      throw new HandlerError({
        type: "NOT_IMPLEMENTED",
        message: "Not implemented",
      });
    }
    return await handler.cancel(ctx, token);
  }
}
