import { OperationInfo, Link } from "./api";

/**
 * Options for the {@link OperationHandler["start"]} method.
 */
export interface StartOperationOptions {
  /** Signaled when the current request is canceled.  */
  abortSignal: AbortSignal;
  headers: Record<string, string>;
  /**
   * Callbacks are used to deliver completion of async operations.
   * This value may optionally be set by the client and should be called by a handler upon completion if the started
   * operation is async.
   */
  callbackURL?: string;
  /**
   * Optional header fields set by a client that are required to be attached to the callback request when an
   * asynchronous operation completes.
   */
  callbackHeader?: Record<string, string>;
  /**
   * Request ID that may be used by the server handler to dedupe a start request.
   * By default a v4 UUID will be generated by the client.
   */
  requestId?: string;
  /**
   * Links contain arbitrary caller information. Handlers may use these links as metadata on resources associated with
   * and operation.
   */
  links: Link[];
}

/**
 * Options for the {@link OperationHandler["getInfo"]} method.
 */
export interface GetOperationInfoOptions {
  /** Signaled when the current request is canceled.  */
  abortSignal: AbortSignal;
  headers: Record<string, string>;
}

/**
 * Options for the {@link OperationHandler["getResult"]} method.
 */
export interface GetOperationResultOptions {
  /** Signaled when the current request is canceled.  */
  abortSignal: AbortSignal;
  headers: Record<string, string>;
  wait: number;
}

/**
 * Options for the {@link OperationHandler["cancel"]} method.
 */
export interface CancelOperationOptions {
  /** Signaled when the current request is canceled.  */
  abortSignal: AbortSignal;
  headers: Record<string, string>;
}

/** A result that indicates that an operation completed successfully. */
export interface HandlerStartOperationResultSync<T> {
  value: T;
}

/** A result that indicates that an operation has been accepted and will complete asynchronously. */
export interface HandlerStartOperationResultAsync {
  // A token to identify the operation in followup handler methods such as {@link OperationHandler.getResult} and {@link
  // OperationHandler.cancel}.
  token: string;
}

// The return type from the {@link OperaitonHandler.start}. May be either a synchronous or asynchornous.
export type HandlerStartOperationResult<T> = HandlerStartOperationResultSync<T> | HandlerStartOperationResultAsync;

declare const inputBrand: unique symbol;
declare const outputBrand: unique symbol;

/**
 * An operation contract that describes the name, and input and output types of an operation.
 */
export interface Operation<I, O> {
  name: string;
  [inputBrand]: I;
  [outputBrand]: O;
}

/**
 * A handler for an operation.
 */
export interface OperationHandler<I, O> {
  /**
   * Handles requests for starting an operation.
   *
   * Return {@link HandlerStartOperationResultSync} to respond successfully - inline, or
   * {@link HandlerStartOperationResultAsync} to indicate that an asynchronous operation was started. Throw a
   * {@link OperationError} to indicate that an operation completed as failed or canceled.
   */
  start(input: I, options: StartOperationOptions): Promise<HandlerStartOperationResult<O>>;

  /**
   * Handles requests to get the result of an asynchronous operation. Return non error result to respond successfully -
   * inline, or error with {@link OperationStillRunningError} to indicate that an asynchronous operation is still
   * running.
   *
   * Throw an {@link OperationError} to indicate that an operation completed as failed or canceled.
   *
   * When {@link GetOperationResultOptions.wait} is greater than zero, this request should be treated as a long poll.
   * Note that the specified wait duration may be longer than the configured client or server side request timeout, and
   * should be handled separately.
   *
   * It is the implementor's responsiblity to respect the client's wait duration and return in a timely fashion, leaving
   * enough time for the request to complete and the response to be sent back.
   *
   * @experimental
   */
  getResult(token: string, options: GetOperationResultOptions): Promise<O>;

  /**
   * GetInfo handles requests to get information about an asynchronous operation.
   *
   * @experimental
   */
  getInfo(token: string, options: GetOperationInfoOptions): Promise<OperationInfo>;

  /**
   * Handles requests to cancel an asynchronous operation.
   *
   * Cancelation in Nexus is:
   * 1. asynchronous - returning from this method only ensures that cancelation is delivered, it may later be
   * ignored by the underlying operation implemention.
   * 2. idempotent - implementors should ignore duplicate cancelations for the same operation.
   */
  cancel(token: string, options: CancelOperationOptions): Promise<void>;
}

/**
 * A shortcut for defining an operation handler that only implements the {@link OperationHandler.start} method and
 * always returns a {@link HandlerStartOperationResultSync}.
 */
export type SyncOperationHandler<I, O> = (input: I, options: StartOperationOptions) => Promise<O>;

/**
 * A named collection of operation handlers.
 */
export type OperationMap = Record<string, Operation<any, any>>;

/**
 * A named collection of partial operation handlers. Input for the {@link service} function.
 */
export type PartialOperationMap = Record<string, PartialOperation<any, any>>;

/**
 * A type that transforms a {@link PartialOperationMap} into an {@link OperationMap}.
 */
export type OperationMapFromPartial<T extends PartialOperationMap> = {
  [K in keyof T & string]: T[K] extends PartialOperation<infer I, infer O> ? Operation<I, O> : never;
};

/**
 * A type that defines a handler for a given operation.
 */
export type OperationHandlerFor<T> =
  T extends Operation<infer I, infer O> ? OperationHandler<I, O> | SyncOperationHandler<I, O> : never;

/**
 * A type that defines a collection of handlers for a given collection of operation interfaces.
 */
export type ServiceHandlerFor<T extends OperationMap = OperationMap> = {
  [K in keyof T & string]: OperationHandlerFor<T[K]>;
};

/**
 * A service contract that includes a name and defines a collection of operations.
 *
 * Can only be constructed by the {@link service} function.
 */
export interface Service<O extends OperationMap = OperationMap> {
  name: string;
  operations: O;
}

/**
 * Constructs a service for a collection of operations.
 */
export function service<O extends PartialOperationMap>(
  name: string,
  operations: O,
): Service<OperationMapFromPartial<O>> {
  const fullOps: OperationMapFromPartial<O> = Object.fromEntries(
    Object.entries(operations).map(([key, op]) => [
      key,
      {
        ...op,
        name: op.name || key,
      },
    ]),
  ) as any; // TS is having a hard time inferring the correct type here.
  return { name, operations: fullOps };
}

/**
 * Options for the {@link operation} function.
 */
export interface OperationOptions<_I, _O> {
  name?: string;
}

/**
 * A partial {@link Operation} that is used to define an operation in a {@link Service}.
 *
 * The difference between this and {@link Operation} is that the name is optional.
 */
export interface PartialOperation<I, O> {
  name?: string;
  [inputBrand]: I;
  [outputBrand]: O;
}

/**
 * Constructs an operation definition as part of a service contract.
 */
export function operation<I, O>(op?: OperationOptions<I, O>): PartialOperation<I, O> {
  return op ?? ({} as any);
}

/**
 * A key that identifies an operation in a service.
 */
export type OperationKey<T> = {
  [K in keyof T & string]: T[K] extends Operation<any, any> ? K : never;
}[keyof T & string];

/**
 * A type that extracts the input type from an operation in a service.
 */
export type OperationInput<T> = T extends Operation<infer I, any> ? I : any;

/**
 * A type that extracts the output type from an operation in a service.
 */
export type OperationOutput<T> = T extends Operation<any, infer O> ? O : any;

/**
 * A {@link Service} that includes a collection of handlers for its operations.
 */
export interface ServiceHandler<T extends OperationMap = OperationMap> extends Service<T> {
  handlers: ServiceHandlerFor<T>;
}

/**
 * Constructs a service handler for a given service contract.
 */
export function serviceHandler<T extends OperationMap>(
  service: Service<T>,
  handlers: ServiceHandlerFor<T>,
): ServiceHandler<T> {
  return {
    ...service,
    handlers,
  };
}
