import { Link, OperationError, OperationInfo } from "./common";
import { Service, OperationKey, OperationInput, OperationOutput } from "./operation";
import { Transport } from "./transport";

interface StartOperationOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;

  /**
   * Callbacks are used to deliver completion of async operations.
   * This value may optionally be set by the client and should be called by a handler upon completion if the started
   * operation is async.
   */
  readonly callbackURL?: string;

  /**
   * Optional header fields set by a client that are required to be attached to the callback request when an
   * asynchronous operation completes.
   */
  readonly callbackHeaders?: Record<string, string>;

  /**
   * Request ID that may be used by the server handler to dedupe a start request.
   * By default a v4 UUID will be generated by the client.
   */
  readonly requestId?: string;

  /**
   * Inbound links that contain arbitrary information, e.g. provided by the caller.
   * Used as metadata for the call.
   */
  readonly links?: Link[];
}

interface CancelOperationOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;
}

interface FetchOperationResultOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;

  /**
   * If specified and non-zero, reflects the duration (in milliseconds) the caller has indicated that it wants to wait
   * for operation completion, turning the request into a long poll.
   *
   * @experimental
   */
  readonly timeoutMs?: number;
}

interface FetchOperationInfoOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;
}

export interface ExecuteOperationOptions extends StartOperationOptions {
  // Duration in milliseconds to wait for operation completion.
  //
  // âš  NOTE: unlike GetOperationResultOptions.wait, zero and negative values are considered effectively infinite.
  readonly timeoutMs?: number | undefined;
}

export interface CompletionOperationOptions {
  /** Result of the operation to complete. */
  readonly headers?: Record<string, string>;
}

export interface ClientStartOperationResponseSync<T> {
  type: "sync";
  readonly links: Link[];
  readonly result: T;
}
export interface ClientStartOperationResponseAsync<T> {
  type: "async";
  readonly links: Link[];
  readonly handle: OperationHandle<T>;
}

export type ClientStartOperationResponse<T> =
  | ClientStartOperationResponseSync<T>
  | ClientStartOperationResponseAsync<T>;

export class ServiceClient<T extends Service> {
  public readonly service: string;

  constructor(
    service: T | string,
    private readonly transport: Transport,
  ) {
    if (typeof service === "string") {
      this.service = service;
    } else {
      this.service = service.name;
    }
  }

  executeOperation<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    input: OperationInput<O>,
    options?: ExecuteOperationOptions,
  ): Promise<OperationOutput<O>>;

  executeOperation<K extends OperationKey<T["operations"]>>(
    op: K,
    input: OperationInput<T["operations"][K]>,
    options?: ExecuteOperationOptions,
  ): Promise<OperationOutput<T["operations"][K]>>;

  async executeOperation(op: any, input: any, options?: ExecuteOperationOptions): Promise<any> {
    const { timeoutMs, ...startOptions } = options ?? {};
    const result = await this.startOperation(op, input, startOptions);
    if (result.type === "sync") {
      return result.result;
    }
    return await result.handle.fetchResult({ timeoutMs });
  }

  startOperation<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    input: OperationInput<O>,
    options?: StartOperationOptions,
  ): Promise<ClientStartOperationResponse<OperationOutput<O>>>;

  startOperation<K extends OperationKey<T["operations"]>>(
    op: K,
    input: OperationInput<T["operations"][K]>,
    options?: StartOperationOptions,
  ): Promise<ClientStartOperationResponse<OperationOutput<T["operations"][K]>>>;

  async startOperation(
    op: any,
    input: any,
    options?: StartOperationOptions,
  ): Promise<ClientStartOperationResponse<any>> {
    const opName = getOpName(op);
    const response = await this.transport.startOperation(
      this.service,
      opName,
      input,
      options ?? {},
    );
    if (response.type === "sync") {
      return {
        type: "sync",
        links: response.links,
        result: response.result,
      };
    }
    return {
      type: "async",
      links: response.links,
      handle: new OperationHandle(this.service, opName, response.token, this.transport),
    };
  }

  getOperationHandle<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    token: string,
  ): OperationHandle<OperationOutput<O>>;

  getOperationHandle<K extends OperationKey<T["operations"]>>(
    op: K,
    token: string,
  ): OperationHandle<OperationOutput<T["operations"][K]>>;

  getOperationHandle(op: any, token: string): OperationHandle<OperationOutput<any>> {
    return new OperationHandle<any>(this.service, getOpName(op), token, this.transport);
  }
}

export class OperationHandle<T> {
  constructor(
    public readonly service: string,
    public readonly operation: string,
    public readonly token: string,
    private readonly transport: Transport,
  ) {}

  async fetchResult(options?: FetchOperationResultOptions): Promise<T> {
    const { result } = await this.fetchResultWithDetails(options);
    return result;
  }

  async fetchResultWithDetails(
    options?: FetchOperationResultOptions,
  ): Promise<ClientResultWithDetails<T>> {
    const { links, result } = await this.transport.getOperationResult(
      this.service,
      this.operation,
      this.token,
      options ?? {},
    );
    return {
      links,
      result: result as T,
    };
  }
  async fetchInfo(options?: FetchOperationInfoOptions): Promise<OperationInfo> {
    const { info } = await this.transport.getOperationInfo(
      this.service,
      this.operation,
      this.token,
      options ?? {},
    );
    return info;
  }

  async cancel(options?: CancelOperationOptions): Promise<void> {
    await this.transport.cancelOperation(this.service, this.operation, this.token, options ?? {});
  }
}

export interface ClientResultWithDetails<T> {
  result: T;
  links: Link[];
}

function getOpName(op: any): string {
  if (
    typeof op === "object" &&
    Object.hasOwnProperty.call(op, "name") &&
    typeof op.name === "string"
  ) {
    return op.name;
  } else if (typeof op === "string") {
    return op;
  }
  throw new TypeError("invalid operation");
}

export class CompletionClient {
  constructor(private readonly transport: Transport) {}

  async succeedOperation(
    url: string,
    result: unknown,
    opts: CompletionOperationOptions,
  ): Promise<void> {
    await this.transport.completeOperation(url, { ...opts, result });
  }

  async failOperation(
    url: string,
    error: OperationError,
    opts: CompletionOperationOptions,
  ): Promise<void> {
    await this.transport.completeOperation(url, { ...opts, error });
  }
}
