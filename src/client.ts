import { Link, OperationInfo } from "./common";
import { Service, OperationKey, OperationInput, OperationOutput } from "./operation";
import { Transport } from "./transport";

interface StartOperationOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;

  /**
   * Callbacks are used to deliver completion of async operations.
   * This value may optionally be set by the client and should be called by a handler upon completion if the started
   * operation is async.
   */
  readonly callbackURL?: string;

  /**
   * Optional header fields set by a client that are required to be attached to the callback request when an
   * asynchronous operation completes.
   */
  readonly callbackHeaders?: Record<string, string>;

  /**
   * Request ID that may be used by the server handler to dedupe a start request.
   * By default a v4 UUID will be generated by the client.
   */
  readonly requestId?: string;

  /**
   * Inbound links that contain arbitrary information, e.g. provided by the caller.
   * Used as metadata for the call.
   */
  readonly links?: Link[];
}

interface CancelOperationOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;
}

interface GetOperationResultOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;

  /**
   * If specified and non-zero, reflects the duration (in milliseconds) the caller has indicated that it wants to wait
   * for operation completion, turning the request into a long poll.
   *
   * @experimental
   */
  readonly timeoutMs?: number;
}

interface GetOperationInfoOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;
}

export interface ExecuteOperationOptions extends StartOperationOptions {
  // Duration in milliseconds to wait for operation completion.
  //
  // âš  NOTE: unlike GetOperationResultOptions.wait, zero and negative values are considered effectively infinite.
  readonly timeoutMs?: number | undefined;
}

export interface ClientStartOperationResultSync<T> {
  isSync: true;
  readonly links: Link[];
  readonly result: T;
}
export interface ClientStartOperationResultAsync<T> {
  isSync: false;
  readonly links: Link[];
  readonly handle: OperationHandle<T>;
}

export type ClientStartOperationResult<T> = ClientStartOperationResultSync<T> | ClientStartOperationResultAsync<T>;

export class ServiceClient<T extends Service> {
  constructor(
    public readonly service: string,
    private readonly transport: Transport,
  ) {
  }

  executeOperation<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    input: OperationInput<O>,
    options?: ExecuteOperationOptions,
  ): Promise<OperationOutput<O>>;

  executeOperation<K extends OperationKey<T["operations"]>>(
    op: K,
    input: OperationInput<T["operations"][K]>,
    options?: ExecuteOperationOptions,
  ): Promise<OperationOutput<T["operations"][K]>>;

  async executeOperation(
    op: any,
    input: any,
    options?: ExecuteOperationOptions,
  ): Promise<any> {
    const { timeoutMs, ...startOptions } = options ?? {};
    const result = await this.startOperation(op, input, startOptions);
    if (result.isSync) {
      return result.result;
    }
    return await result.handle.getResult({ timeoutMs });
  }

  startOperation<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    input: OperationInput<O>,
    options?: StartOperationOptions,
  ): Promise<ClientStartOperationResult<OperationOutput<O>>>;

  startOperation<K extends OperationKey<T["operations"]>>(
    op: K,
    input: OperationInput<T["operations"][K]>,
    options?: StartOperationOptions,
  ): Promise<ClientStartOperationResult<OperationOutput<T["operations"][K]>>>;

  async startOperation(
    op: any,
    input: any,
    options?: StartOperationOptions,
  ): Promise<ClientStartOperationResult<any>> {
    const opName = getOpName(op)
    const response = await this.transport.startOperation(this.service, opName, input, options ?? {});
    if (response.isSync) {
      return {
        isSync: true,
        links: response.links,
        result: response.result,
      };
    }
    return {
      isSync: false,
      links: response.links,
      handle: new OperationHandle(
        this.service,
        opName,
        response.token,
        this.transport,
      ),
    };
  }

  getOperationHandle<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    token: string,
  ): OperationHandle<OperationOutput<O>>;

  getOperationHandle<K extends OperationKey<T["operations"]>>(
    op: K,
    token: string,
  ): OperationHandle<OperationOutput<T["operations"][K]>>;

  getOperationHandle(
    op: any,
    token: string,
  ): OperationHandle<OperationOutput<any>> {
    return new OperationHandle<any>(
      this.service,
      getOpName(op),
      token,
      this.transport,
    );
  }
}

export class OperationHandle<T> {
  constructor(
    public readonly service: string,
    public readonly operation: string,
    public readonly token: string,
    private readonly transport: Transport,
  ) {}

  async getResult(options?: GetOperationResultOptions): Promise<T> {
    const { result } = await this.getResultWithDetails(options);
    return result;
  }

  async getResultWithDetails(options?: GetOperationResultOptions): Promise<ClientResultWithDetails<T>> {
    const { links, result } = await this.transport.getOperationResult(
      this.service,
      this.operation,
      this.token,
      options ?? {},
    );
    return {
      links,
      result: result as T,
    };
  }
  async getInfo(options?: GetOperationInfoOptions): Promise<OperationInfo> {
    const { info } = await this.transport.getOperationInfo(
      this.service,
      this.operation,
      this.token,
      options ?? {},
    );
    return info;
  }

  async cancel(options?: CancelOperationOptions): Promise<void> {
    await this.transport.cancelOperation(
      this.service,
      this.operation,
      this.token,
      options ?? {},
    );
  }
}

export interface ClientResultWithDetails<T> {
  result: T;
  links: Link[];
}

function getOpName(op: any): string {
    if (typeof op === "object" && Object.hasOwnProperty.call(op, "name") && typeof op.name === "string") {
    return op.name;
    } else if (typeof op === "string") {
    return op;
    }
    throw new TypeError('invalid operation');
}
