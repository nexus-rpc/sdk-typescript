import { Link, OperationInfo } from "./common";
import { Service, OperationKey, OperationInput, OperationOutput } from "./operation";

interface StartOperationOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;

  /**
   * Callbacks are used to deliver completion of async operations.
   * This value may optionally be set by the client and should be called by a handler upon completion if the started
   * operation is async.
   */
  readonly callbackURL?: string;

  /**
   * Optional header fields set by a client that are required to be attached to the callback request when an
   * asynchronous operation completes.
   */
  readonly callbackHeaders?: Record<string, string>;

  /**
   * Request ID that may be used by the server handler to dedupe a start request.
   * By default a v4 UUID will be generated by the client.
   */
  readonly requestId?: string;

  /**
   * Inbound links that contain arbitrary information, e.g. provided by the caller.
   * Used as metadata for the call.
   */
  readonly inboundLinks?: Link[];
}

interface CancelOperationOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;
}

interface GetOperationResultOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;

  /**
   * If specified and non-zero, reflects the duration (in milliseconds) the caller has indicated that it wants to wait
   * for operation completion, turning the request into a long poll.
   *
   * @experimental
   */
  readonly timeoutMs?: number;
}

interface GetOperationInfoOptions {
  /** Request header fields. */
  readonly headers?: Record<string, string>;

  /** Signal to cancel an inflight request. */
  readonly abortSignal?: AbortSignal;
}

export interface ExecuteOperationOptions extends StartOperationOptions {
  // Duration in milliseconds to wait for operation completion.
  //
  // âš  NOTE: unlike GetOperationResultOptions.wait, zero and negative values are considered effectively infinite.
  readonly timeoutMs?: number | undefined;
}

export interface ClientStartOperationResultSync<T> {
  isSync(): this is ClientStartOperationResultSync<T>;
  readonly links: Link[];
  readonly result: T;
}
export interface ClientStartOperationResultAsync<T> {
  isSync(): this is ClientStartOperationResultSync<T>;
  readonly links: Link[];
  readonly handle: OperationHandle<T>;
}

export type ClientStartOperationResult<T> = ClientStartOperationResultSync<T> | ClientStartOperationResultAsync<T>;

export interface ServiceClient<T extends Service> {
  executeOperation<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    input: OperationInput<O>,
    options?: ExecuteOperationOptions,
  ): Promise<OperationOutput<O>>;

  executeOperation<K extends OperationKey<T["operations"]>>(
    op: K,
    input: OperationInput<T["operations"][K]>,
    options?: ExecuteOperationOptions,
  ): Promise<OperationOutput<T["operations"][K]>>;

  startOperation<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    input: OperationInput<O>,
    options?: StartOperationOptions,
  ): Promise<ClientStartOperationResult<OperationOutput<O>>>;

  startOperation<K extends OperationKey<T["operations"]>>(
    op: K,
    input: OperationInput<T["operations"][K]>,
    options?: StartOperationOptions,
  ): Promise<ClientStartOperationResult<OperationOutput<T["operations"][K]>>>;

  getOperationHandle<O extends T["operations"][keyof T["operations"]]>(
    op: O,
    token: string,
  ): OperationHandle<OperationOutput<O>>;

  getOperationHandle<K extends OperationKey<T["operations"]>>(
    op: K,
    token: string,
  ): OperationHandle<OperationOutput<T["operations"][K]>>;
}

export interface OperationHandle<T> {
  readonly service: string;
  readonly operation: string;
  readonly token: string;

  getResult(options?: GetOperationResultOptions): Promise<T>;
  getResultWithResponse(options?: GetOperationResultOptions): Promise<GetResultResponse<T>>;
  getInfo(options?: GetOperationInfoOptions): Promise<OperationInfo>;
  cancel(options?: CancelOperationOptions): Promise<void>;
}

export interface GetResultResponse<T> {
  result: T;
  links: Link[];
}
